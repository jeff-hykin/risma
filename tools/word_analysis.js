import { zip, enumerate, count, permute, combinations, wrapAroundGet } from "https://deno.land/x/good@1.13.5.0/array.js"
import { zipShort } from "https://deno.land/x/good@1.13.1.0/flattened/zip_short.js"
import { frequencyCount } from "https://esm.sh/gh/jeff-hykin/good-js@1.14.2.0/source/flattened/frequency_count.js"

export const boringWords = [
    "the",
    "be",
    "to",
    "of",
    "and",
    "a",
    "in",
    "that",
    "have",
    "I",
    "it",
    "for",
    "not",
    "on",
    "with",
    "he",
    "as",
    "you",
    "do",
    "at",
    "this",
    "but",
    "his",
    "by",
    "from",
    "they",
    "we",
    "say",
    "her",
    "she",
    "or",
    "an",
    "will",
    "my",
    "one",
    "all",
    "would",
    "there",
    "their",
    "what",
    "so",
    "up",
    "out",
    "if",
    "about",
    "who",
    "get",
    "which",
    "go",
    "me",
    "when",
    "make",
    "can",
    "like",
    "time",
    "no",
    "just",
    "him",
    "know",
    "take",
    "people",
    "into",
    "year",
    "your",
    "good",
    "some",
    "could",
    "them",
    "see",
    "other",
    "than",
    "then",
    "now",
    "look",
    "only",
    "come",
    "its",
    "over",
    "think",
    "also",
    "back",
    "after",
    "use",
    "two",
    "how",
    "our",
    "work",
    "first",
    "well",
    "way",
    "even",
    "new",
    "want",
    "because",
    "any",
    "these",
    "give",
    "day",
    "most",
    "are",
    "show",
    "using",
    "where",
    "has",
    "was",
    "very",
    "must",
    "need",
    "were",
    "is",
    "should",
    "us",
]
export const genericSingularWords = [
    "theory",
    "model",
    "data",
    "approach",
    "method",
]
export const relevantWords = [
    'acquisition',
    'action',
    'activity',
    'afford',
    'affordance',
    'agent',
    'analysis',
    'applications',
    'autonomous',
    'based',
    'bayesian',
    'behavior',
    'beyond',
    'categories',
    'category',
    'children',
    'classification',
    'cognition',
    'cognitive',
    'computational',
    'computer',
    'computing',
    'concept',
    'construction',
    'context',
    'control',
    'convolutional',
    'culture',
    'deep',
    'design',
    'detection',
    'development',
    'developmental',
    'direct',
    'driven',
    'driving',
    'dynamics',
    'ecological',
    'ecology',
    'embodied',
    'engineering',
    'environment',
    'exploration',
    'features',
    'field',
    'framework',
    'functional',
    'gibson',
    'goal',
    'grasp',
    'grasping',
    'grounded',
    'grounding',
    'guided',
    'human',
    'images',
    'information',
    'intelligent',
    'intention',
    'interaction',
    'interactive',
    'interface',
    'james',
    'knowledge',
    'landscape',
    'language',
    'learned',
    'learning',
    'level',
    'locomotion',
    'machine',
    'manipulation',
    'media',
    'mining',
    'mobile',
    'modeling',
    'models',
    'multi',
    'natural',
    'network',
    'networks',
    'neural',
    'new',
    'niche',
    'object',
    'perceive',
    'perceived',
    'perceiving',
    'perception',
    'perceptual',
    'perspective',
    'physical',
    'planning',
    'policy',
    'practice',
    'prediction',
    'predictive',
    'principles',
    'properties',
    'psychology',
    'reasoning',
    'recognition',
    'reinforcement',
    'representation',
    'research',
    'response',
    'review',
    'robot',
    'robots',
    'role',
    'science',
    'segmentation',
    'self',
    'semantic',
    'sensory',
    'sets',
    'simulation',
    'situated',
    'smart',
    'social',
    'space',
    'spatio',
    'sport',
    'studies',
    'study',
    'survey',
    'system',
    'systems',
    'technology',
    'temporal',
    'tool',
    'towards',
    'understanding',
    'use',
    'user',
    'via',
    'virtual',
    'vision',
    'visual',
    'wayfinding',
    'world',
]

export function getTerms(string, {excludeWords=boringWords}={}) {
    // handle dashes a bit differently:
    // return string.replace(/(\w+)((-\w+)+)/g,each=>`${each.replace(/-/g,"_")} ${each.replace(/-/g," ")}`).replace(/-/g," ").toLowerCase().split(/\s+/g).filter(each=>each.length && each.match(/^\w+$/) && !excludeWords.includes(each)).map(each=>each.replace(/_/g,"-"))
    return string.replace(/-/g," ").toLowerCase().split(/\s+/g).filter(each=>each.length && each.match(/^\w+$/) && !excludeWords.includes(each))
}

export function getPairedFrequency(listOfStrings, {excludeWords=boringWords}={}) {
    var pairs = listOfStrings.flat(Infinity).map(each=>getTerms(each, {excludeWords})).map(
        each=>[...zipShort(each,each.slice(1))].map(each=>each.join(" "))
    ).flat(2)
    return frequencyCount(pairs, {sort:1})
}

export function getPairedFrequencyNoInnerDuplicates(listOfStrings, {excludeWords=boringWords}={}) {
    var pairs = listOfStrings.flat(Infinity).map(
        each=>[...new Set(getTerms(each, {excludeWords}))]
    ).map(
        each=>[...zipShort(each,each.slice(1))].map(each=>each.join(" "))
    ).flat(2)
    return frequencyCount(pairs, {sort:1})
}

export function getWordFrequency(listOfStrings, {excludeWords=boringWords}={}) {
    var pairs = listOfStrings.flat(Infinity).map(
        each=>getTerms(each, {excludeWords})
    ).flat(2)
    return frequencyCount(pairs, {sort:1})
}

export function getWordFrequencyNoInnerDuplicates(listOfStrings, {excludeWords=boringWords}={}) {
    var pairs = listOfStrings.flat(Infinity).map(
        each=>[...new Set(getTerms(each, {excludeWords}))]
    ).flat(2)
    return frequencyCount(pairs, {sort:1})
}