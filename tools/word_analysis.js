import { zip, enumerate, count, permute, combinations, wrapAroundGet } from "https://deno.land/x/good@1.13.5.0/array.js"
import { zipShort } from "https://deno.land/x/good@1.13.1.0/flattened/zip_short.js"
import { frequencyCount } from "https://esm.sh/gh/jeff-hykin/good-js@1.14.2.0/source/flattened/frequency_count.js"

export const boringWords = [
    "the",
    "be",
    "to",
    "of",
    "and",
    "a",
    "in",
    "that",
    "have",
    "I",
    "it",
    "for",
    "not",
    "on",
    "with",
    "he",
    "as",
    "you",
    "do",
    "at",
    "this",
    "but",
    "his",
    "by",
    "from",
    "they",
    "we",
    "say",
    "her",
    "she",
    "or",
    "an",
    "will",
    "my",
    "one",
    "all",
    "would",
    "there",
    "their",
    "what",
    "so",
    "up",
    "out",
    "if",
    "about",
    "who",
    "get",
    "which",
    "go",
    "me",
    "when",
    "make",
    "can",
    "like",
    "time",
    "no",
    "just",
    "him",
    "know",
    "take",
    "people",
    "into",
    "year",
    "your",
    "good",
    "some",
    "could",
    "them",
    "see",
    "other",
    "than",
    "then",
    "now",
    "look",
    "only",
    "come",
    "its",
    "over",
    "think",
    "also",
    "back",
    "after",
    "use",
    "two",
    "how",
    "our",
    "work",
    "first",
    "well",
    "way",
    "even",
    "new",
    "want",
    "because",
    "any",
    "these",
    "give",
    "day",
    "most",
    "are",
    "show",
    "using",
    "where",
    "has",
    "was",
    "very",
    "must",
    "need",
    "were",
    "is",
    "should",
    "us",
    "through",
    "such",
    "propose",
    "between",
    "used",
    "both",
    "been",
    "those",
    // boring just for this application
    "state-of-the-art",
]
export const genericSingularWords = [
    "theory",
    "model",
    "data",
    "approach",
    "method",
    "information",
    "research",
    "able",
    "more",
    "proposed",
    "allows",
    "level",
    "set",
    "each",
    "art",
    "while",
    "provides",
    "specific",
    "multiple",
    "large",
    "during",
    "existing",
    "order",
    "complex",
    "paper",
    "three",
    "high",
    "number",
    "field",
    "relevant",
    "effectively",
    "provide",
    "among",
    "perform",
    "many",
    "literature",
    "enable",
    "parts",
    "without",
    "allow",
    "within",
    "may",
    "per",
    "since",
]
export const termMapping = {
    "affordances": "affordance",
    "objects": "object",
    "robots": "robot",
    "robotics": "robot",
    "robotic": "robot",
    "networks": "network",
    "models": "model",
    "tasks": "task",
    "approaches": "approach",
    "perceptions": "perception",
    "humans": "human",
    "actions": "action",
    "representations": "representation",
    "interactions": "interaction",
    "scenes": "scene",
    "features": "feature",
    "tools": "tool",
    "environments": "environment",
    "methods": "method",
    "detections": "detection",
    "goals": "goal",
    "results": "result",
    "videos": "video",
    "machines": "machine",
    "behaviors": "behavior",
    "concepts": "concept",
    "agents": "agent",
    "grasping": "grasp",
    "grasped": "grasp",
    "demonstrated": "demonstrate",
    "demonstrates": "demonstrate",
    "proposed": "propose",
    "training": "train",
    "trained": "train",
    "images": "image",
    "problems": "problem",
    "predictions": "predict",
    "prediction": "predict",
    "predicting": "predict",
    "predictive": "predict",
    "effects": "effect",
    "affects": "affect",
    "perceptual": "perception",
    "perceive": "perception",
    "perceived": "perception",
    "captures": "capture",
    "policies": "policy",
    "studies": "study",
    "appearances": "appearance",
    "hands": "hand",
    "inputs": "input",
    "outputs": "output",
    "algorithms": "algorithm",
    "labels": "label",
    "describes": "describe",
    "mechanisms": "mechanism",
    "motors": "motor",
    "controllers": "controller",
    "imagination": "imagine",
    "fields": "field",
    "challenges": "challenge",
    "presents": "present",
    "outcomes": "outcome",
    "learns": "learn",
    "situatedness": "situated",
    "situational": "situated",
    "emulated": "simulate",
    "simulated": "simulate",
    "simulation": "simulate",
    "optic": "optical",
    // "learned": "learn",
}
export const relevantWords = [
    'acquisition',
    'action',
    'activity',
    'afford',
    'affordance',
    'agent',
    'analysis',
    'applications',
    'autonomous',
    'based',
    'bayesian',
    'behavior',
    'beyond',
    'categories',
    'category',
    'children',
    'classification',
    'cognition',
    'cognitive',
    'computational',
    'computer',
    'computing',
    'concept',
    'construction',
    'context',
    'control',
    'convolutional',
    'culture',
    'deep',
    'design',
    'detection',
    'development',
    'developmental',
    'direct',
    'driven',
    'driving',
    'dynamics',
    'ecological',
    'ecology',
    'embodied',
    'engineering',
    'environment',
    'exploration',
    'features',
    'field',
    'framework',
    'functional',
    'gibson',
    'goal',
    'grasp',
    'grasping',
    'grounded',
    'grounding',
    'guided',
    'human',
    'images',
    'information',
    'intelligent',
    'intention',
    'interaction',
    'interactive',
    'interface',
    'james',
    'knowledge',
    'landscape',
    'language',
    'learned',
    'learning',
    'level',
    'locomotion',
    'machine',
    'manipulation',
    'media',
    'mining',
    'mobile',
    'modeling',
    'models',
    'multi',
    'natural',
    'network',
    'networks',
    'neural',
    'new',
    'niche',
    'object',
    'perceive',
    'perceived',
    'perceiving',
    'perception',
    'perceptual',
    'perspective',
    'physical',
    'planning',
    'policy',
    'practice',
    'prediction',
    'predictive',
    'principles',
    'properties',
    'psychology',
    'reasoning',
    'recognition',
    'reinforcement',
    'representation',
    'research',
    'response',
    'review',
    'robot',
    'robots',
    'role',
    'science',
    'segmentation',
    'self',
    'semantic',
    'sensory',
    'sets',
    'simulation',
    'situated',
    'smart',
    'social',
    'space',
    'spatio',
    'sport',
    'studies',
    'study',
    'survey',
    'system',
    'systems',
    'technology',
    'temporal',
    'tool',
    'towards',
    'understanding',
    'use',
    'user',
    'via',
    'virtual',
    'vision',
    'visual',
    'wayfinding',
    'world',
]
export function getTerms(string, {excludeWords=boringWords}={}) {
    // handle dashes a bit differently:
    // return string.replace(/(\w+)((-\w+)+)/g,each=>`${each.replace(/-/g,"_")} ${each.replace(/-/g," ")}`).replace(/-/g," ").toLowerCase().split(/\s+/g).filter(each=>each.length && each.match(/^\w+$/) && !excludeWords.includes(each)).map(each=>each.replace(/_/g,"-"))
    return string.replace(/-/g," ").toLowerCase().split(/\s+/g).filter(each=>each.length && each.match(/^\w+$/) && !excludeWords.includes(each)).map(each=>termMapping[each] || each)
}

export function getPairedFrequency(listOfStrings, {excludeWords=boringWords}={}) {
    var pairs = listOfStrings.flat(Infinity).map(each=>getTerms(each, {excludeWords})).map(
        each=>[...zipShort(each,each.slice(1))].map(each=>each.join(" "))
    ).flat(2)
    return frequencyCount(pairs, {sort:1})
}

export function getPairedFrequencyNoInnerDuplicates(listOfStrings, {excludeWords=boringWords}={}) {
    var pairs = listOfStrings.flat(Infinity).map(
        each=>[...new Set(getTerms(each, {excludeWords}))]
    ).map(
        each=>[...zipShort(each,each.slice(1))].map(each=>each.join(" "))
    ).flat(2)
    return frequencyCount(pairs, {sort:1})
}

export function getWordFrequency(listOfStrings, {excludeWords=boringWords}={}) {
    var pairs = listOfStrings.flat(Infinity).map(
        each=>getTerms(each, {excludeWords}).filter(each=>!genericSingularWords.includes(each))
    ).flat(2)
    return frequencyCount(pairs, {sort:1})
}

export function getWordFrequencyNoInnerDuplicates(listOfStrings, {excludeWords=boringWords}={}) {
    var pairs = listOfStrings.flat(Infinity).map(
        each=>[...new Set(getTerms(each, {excludeWords}))]
    ).flat(2)
    return frequencyCount(pairs, {sort:1})
}